//
//  MalwarePatternDetector.swift
//  NMAPScanner - Malware Communication Pattern Detection
//
//  Created by Jordan Koch & Claude Code on 2025-11-27.
//

import Foundation

struct MalwareIndicator: Identifiable, Codable {
    let id = UUID()
    let sourceIP: String
    let destinationIP: String
    let pattern: PatternType
    let severity: Severity
    let description: String
    let recommendation: String
    let timestamp: Date

    enum PatternType: String, Codable {
        case c2Communication = "C2 Server Communication"
        case cryptoMining = "Cryptocurrency Mining"
        case torConnection = "Tor Network Connection"
        case beaconing = "Regular Beaconing Pattern"
        case fastFlux = "Fast-Flux DNS"
        case p2pMalware = "P2P Malware Traffic"
    }

    enum Severity: String, Codable {
        case critical, high, medium
    }
}

@MainActor
class MalwarePatternDetector: ObservableObject {
    static let shared = MalwarePatternDetector()

    @Published var indicators: [MalwareIndicator] = []
    @Published var isScanning = false

    private let cryptoMiningPorts = [3333, 4444, 5555, 7777, 8333, 9332, 9999]
    private let torPorts = [9001, 9030, 9050, 9051]
    private let knownC2IPs = ["malicious.example.com"] // Threat intel feed

    private init() {}

    func detectMalwarePatterns(connections: [SegmentationConnection], devices: [EnhancedDevice]) async {
        isScanning = true
        indicators.removeAll()

        // Check for crypto mining
        for device in devices {
            for port in cryptoMiningPorts {
                if device.openPorts.contains(where: { $0.port == port }) {
                    indicators.append(MalwareIndicator(
                        sourceIP: device.ipAddress,
                        destinationIP: "",
                        pattern: .cryptoMining,
                        severity: .high,
                        description: "Cryptocurrency mining port \(port) detected",
                        recommendation: "Investigate device for unauthorized mining software. Check CPU usage.",
                        timestamp: Date()
                    ))
                }
            }
        }

        // Check for Tor connections
        for device in devices {
            for port in torPorts {
                if device.openPorts.contains(where: { $0.port == port }) {
                    indicators.append(MalwareIndicator(
                        sourceIP: device.ipAddress,
                        destinationIP: "",
                        pattern: .torConnection,
                        severity: .medium,
                        description: "Tor network port detected - possible data exfiltration",
                        recommendation: "Verify legitimate use. Block Tor if not authorized.",
                        timestamp: Date()
                    ))
                }
            }
        }

        // Check for beaconing patterns
        let beaconingDevices = detectBeaconing(connections: connections)
        for device in beaconingDevices {
            indicators.append(MalwareIndicator(
                sourceIP: device,
                destinationIP: "",
                pattern: .beaconing,
                severity: .critical,
                description: "Regular beaconing pattern detected - typical of C2 communication",
                recommendation: "Isolate device immediately. Run malware scan. Analyze network traffic.",
                timestamp: Date()
            ))
        }

        isScanning = false
    }

    private func detectBeaconing(connections: [SegmentationConnection]) -> [String] {
        var connectionTimes: [String: [Date]] = [:]

        // Group connections by source IP
        for connection in connections {
            connectionTimes[connection.sourceIP, default: []].append(Date())
        }

        var beaconingIPs: [String] = []

        // Analyze for regular intervals (beaconing)
        for (ip, times) in connectionTimes where times.count > 5 {
            let sortedTimes = times.sorted()
            var intervals: [TimeInterval] = []

            for i in 1..<sortedTimes.count {
                intervals.append(sortedTimes[i].timeIntervalSince(sortedTimes[i-1]))
            }

            // Check if intervals are regular (within 10% variance)
            if let avgInterval = intervals.first, intervals.allSatisfy({ abs($0 - avgInterval) / avgInterval < 0.1 }) {
                beaconingIPs.append(ip)
            }
        }

        return beaconingIPs
    }
}
