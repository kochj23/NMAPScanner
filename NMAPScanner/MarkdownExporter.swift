//
//  MarkdownExporter.swift
//  NMAPScanner - Markdown Export for GitHub/Documentation
//
//  Export scan results to Markdown format for easy sharing
//  Created by Jordan Koch on 2025-12-11.
//

import Foundation

struct MarkdownExporter {

    /// Export scan results to Markdown format
    static func exportToMarkdown(devices: [EnhancedDevice], threats: [ThreatFinding] = [], scanDate: Date = Date()) -> String {
        var markdown = ""

        // Header
        markdown += "# Network Scan Report\n\n"
        markdown += "**Date**: \(formatDate(scanDate))\n"
        markdown += "**Devices Found**: \(devices.count)\n"
        markdown += "**Online Devices**: \(devices.filter { $0.isOnline }.count)\n"
        markdown += "**Threats Detected**: \(threats.count)\n\n"

        markdown += "---\n\n"

        // Executive Summary
        markdown += "## Executive Summary\n\n"
        markdown += generateExecutiveSummary(devices: devices, threats: threats)
        markdown += "\n"

        // Threat Overview
        if !threats.isEmpty {
            markdown += "## ðŸš¨ Security Threats\n\n"
            markdown += generateThreatSection(threats: threats)
            markdown += "\n"
        }

        // Device Statistics
        markdown += "## ðŸ“Š Device Statistics\n\n"
        markdown += generateStatistics(devices: devices)
        markdown += "\n"

        // Device Inventory
        markdown += "## ðŸ“± Device Inventory\n\n"
        markdown += generateDeviceTable(devices: devices)
        markdown += "\n"

        // Device Details
        markdown += "## ðŸ” Detailed Device Information\n\n"
        markdown += generateDeviceDetails(devices: devices)
        markdown += "\n"

        // Recommendations
        markdown += "## ðŸ’¡ Recommendations\n\n"
        markdown += generateRecommendations(devices: devices, threats: threats)
        markdown += "\n"

        // Footer
        markdown += "---\n\n"
        markdown += "*Generated by NMAPScanner v8.5.0*\n"
        markdown += "*Created by Jordan Koch*\n"

        return markdown
    }

    // MARK: - Section Generators

    private static func generateExecutiveSummary(devices: [EnhancedDevice], threats: [ThreatFinding]) -> String {
        var summary = ""

        let onlineCount = devices.filter { $0.isOnline }.count
        let rogueCount = devices.filter { $0.isRogue }.count
        let criticalThreats = threats.filter { $0.severity == .critical }.count
        let highThreats = threats.filter { $0.severity == .high }.count

        summary += "This report covers **\(devices.count) devices** discovered on the network.\n\n"

        if onlineCount > 0 {
            summary += "- âœ… **\(onlineCount) devices** are currently online\n"
        }

        if rogueCount > 0 {
            summary += "- âš ï¸ **\(rogueCount) rogue devices** detected (unknown/untrusted)\n"
        }

        if criticalThreats > 0 {
            summary += "- ðŸš¨ **\(criticalThreats) critical threats** require immediate attention\n"
        }

        if highThreats > 0 {
            summary += "- âš ï¸ **\(highThreats) high-severity threats** found\n"
        }

        if threats.isEmpty && rogueCount == 0 {
            summary += "- âœ… **No significant security threats** detected\n"
        }

        // Device type breakdown
        let deviceTypes = Dictionary(grouping: devices, by: { $0.deviceType })
        summary += "\n**Device Types**:\n"
        for (type, devicesOfType) in deviceTypes.sorted(by: { $0.value.count > $1.value.count }) {
            summary += "- \(type.rawValue): \(devicesOfType.count)\n"
        }

        return summary
    }

    private static func generateThreatSection(threats: [ThreatFinding]) -> String {
        var section = ""

        let grouped = Dictionary(grouping: threats, by: { $0.severity })

        for severity in [ThreatSeverity.critical, .high, .medium, .low] {
            guard let threatsOfSeverity = grouped[severity], !threatsOfSeverity.isEmpty else { continue }

            let emoji = severity == .critical ? "ðŸš¨" : severity == .high ? "âš ï¸" : severity == .medium ? "âš¡" : "â„¹ï¸"

            section += "### \(emoji) \(severity.rawValue) Severity (\(threatsOfSeverity.count))\n\n"

            for threat in threatsOfSeverity.prefix(10) {  // Top 10 per severity
                section += "- **\(threat.title)**\n"
                section += "  - Host: `\(threat.affectedHost)`\n"
                section += "  - Category: \(threat.category.rawValue)\n"

                if let cvss = threat.cvssScore {
                    section += "  - CVSS Score: \(String(format: "%.1f", cvss))\n"
                }

                section += "  - Description: \(threat.description)\n"
                section += "\n"
            }
        }

        return section
    }

    private static func generateStatistics(devices: [EnhancedDevice]) -> String {
        var stats = ""

        let onlineCount = devices.filter { $0.isOnline }.count
        let offlineCount = devices.count - onlineCount
        let rogueCount = devices.filter { $0.isRogue }.count
        let knownCount = devices.filter { $0.isKnownDevice }.count

        stats += "| Metric | Count |\n"
        stats += "|--------|-------|\n"
        stats += "| Total Devices | \(devices.count) |\n"
        stats += "| Online | \(onlineCount) |\n"
        stats += "| Offline | \(offlineCount) |\n"
        stats += "| Known/Trusted | \(knownCount) |\n"
        stats += "| Rogue/Unknown | \(rogueCount) |\n"

        // Open ports statistics
        let totalOpenPorts = devices.reduce(0) { $0 + $1.openPorts.count }
        let avgPortsPerDevice = devices.isEmpty ? 0 : totalOpenPorts / devices.count

        stats += "| Total Open Ports | \(totalOpenPorts) |\n"
        stats += "| Avg Ports/Device | \(avgPortsPerDevice) |\n"

        // Manufacturer breakdown
        let manufacturers = Dictionary(grouping: devices, by: { $0.manufacturer ?? "Unknown" })
        stats += "\n### Top Manufacturers\n\n"
        for (manufacturer, devs) in manufacturers.sorted(by: { $0.value.count > $1.value.count }).prefix(5) {
            stats += "- **\(manufacturer)**: \(devs.count) devices\n"
        }

        return stats
    }

    private static func generateDeviceTable(devices: [EnhancedDevice]) -> String {
        var table = ""

        table += "| IP Address | Hostname | Manufacturer | Type | Ports | Status |\n"
        table += "|------------|----------|--------------|------|-------|--------|\n"

        for device in devices.sorted(by: { $0.ipAddress < $1.ipAddress }) {
            let ip = device.ipAddress
            let hostname = device.hostname ?? "-"
            let manufacturer = device.manufacturer ?? "Unknown"
            let type = device.deviceType.rawValue
            let ports = device.openPorts.map { String($0.port) }.joined(separator: ", ")
            let status = device.isOnline ? "âœ… Online" : "â­• Offline"

            table += "| `\(ip)` | \(hostname) | \(manufacturer) | \(type) | \(ports) | \(status) |\n"
        }

        return table
    }

    private static func generateDeviceDetails(devices: [EnhancedDevice]) -> String {
        var details = ""

        for device in devices.filter({ $0.isOnline }).sorted(by: { $0.ipAddress < $1.ipAddress }) {
            details += "### \(device.hostname ?? device.ipAddress)\n\n"

            details += "**IP Address**: `\(device.ipAddress)`\n"

            if let mac = device.macAddress {
                details += "**MAC Address**: `\(mac)`\n"
            }

            if let manufacturer = device.manufacturer {
                details += "**Manufacturer**: \(manufacturer)\n"
            }

            details += "**Device Type**: \(device.deviceType.rawValue)\n"
            details += "**Status**: \(device.isOnline ? "âœ… Online" : "â­• Offline")\n"

            if device.isRogue {
                details += "**Security**: âš ï¸ **ROGUE DEVICE** (Unknown/Untrusted)\n"
            }

            if !device.openPorts.isEmpty {
                details += "\n**Open Ports**:\n"
                for port in device.openPorts.sorted(by: { $0.port < $1.port }) {
                    details += "- Port \(port.port): \(port.service)"
                    if let version = port.version {
                        details += " (\(version))"
                    }
                    details += "\n"
                }
            }

            details += "\n"
        }

        return details
    }

    private static func generateRecommendations(devices: [EnhancedDevice], threats: [ThreatFinding]) -> String {
        var recommendations: [String] = []

        // Check for common issues
        let rogueCount = devices.filter { $0.isRogue }.count
        if rogueCount > 0 {
            recommendations.append("ðŸ” **Review \(rogueCount) rogue devices** - Whitelist trusted devices, investigate unknown devices")
        }

        let telnetDevices = devices.filter { $0.openPorts.contains { $0.port == 23 } }
        if !telnetDevices.isEmpty {
            recommendations.append("ðŸ”’ **Disable Telnet** - Found on \(telnetDevices.count) devices. Use SSH instead (port 22)")
        }

        let defaultWebPorts = devices.filter { $0.openPorts.contains { $0.port == 8080 || $0.port == 8000 } }
        if !defaultWebPorts.isEmpty {
            recommendations.append("ðŸŒ **Secure Web Services** - \(defaultWebPorts.count) devices with non-standard HTTP ports. Ensure authentication enabled")
        }

        let criticalThreats = threats.filter { $0.severity == .critical }
        if !criticalThreats.isEmpty {
            recommendations.append("ðŸš¨ **Address \(criticalThreats.count) critical threats immediately** - These pose significant security risks")
        }

        if devices.filter({ $0.deviceType == .iot }).count > 5 {
            recommendations.append("ðŸ  **Consider IoT network segmentation** - Isolate IoT devices on separate VLAN for security")
        }

        if recommendations.isEmpty {
            recommendations.append("âœ… **Network looks good!** No immediate security concerns detected")
        }

        return recommendations.map { "- \($0)\n" }.joined()
    }

    // MARK: - Utilities

    private static func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        formatter.timeStyle = .medium
        return formatter.string(from: date)
    }

    /// Save markdown to file
    static func saveToFile(_ markdown: String, filename: String = "network_scan_report") throws -> URL {
        let timestamp = ISO8601DateFormatter().string(from: Date())
            .replacingOccurrences(of: ":", with: "-")
        let finalFilename = "\(filename)_\(timestamp).md"

        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let fileURL = documentsPath.appendingPathComponent(finalFilename)

        try markdown.write(to: fileURL, atomically: true, encoding: .utf8)

        SecureLogger.log("Exported markdown report to: \(fileURL.path)", level: .info)

        return fileURL
    }
}
