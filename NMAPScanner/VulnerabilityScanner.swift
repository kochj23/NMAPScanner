//
//  VulnerabilityScanner.swift
//  NMAP Scanner - Vulnerability Detection
//
//  Created by Jordan Koch on 2025-11-23.
//

import Foundation
import Network

/// Represents a security vulnerability
struct Vulnerability: Identifiable {
    let id = UUID()
    let type: VulnerabilityType
    let severity: Severity
    let host: String
    let port: Int?
    let description: String
    let recommendation: String
    let detectedAt: Date

    enum VulnerabilityType: String {
        case openTelnet = "Open Telnet"
        case openFTP = "Open FTP"
        case anonymousFTP = "Anonymous FTP"
        case openSMTP = "Open SMTP Relay"
        case weakSSL = "Weak SSL/TLS"
        case exposedDatabase = "Exposed Database"
        case defaultCredentials = "Default Credentials"
        case openDNS = "Open DNS Resolver"
        case unauthorizedAccess = "Unauthorized Access"
        case insecureService = "Insecure Service"
        case missingEncryption = "Missing Encryption"
        case suspiciousPort = "Suspicious Port"
    }

    enum Severity: String, Comparable {
        case critical = "Critical"
        case high = "High"
        case medium = "Medium"
        case low = "Low"
        case info = "Info"

        var color: String {
            switch self {
            case .critical: return "red"
            case .high: return "orange"
            case .medium: return "yellow"
            case .low: return "blue"
            case .info: return "gray"
            }
        }

        var score: Int {
            switch self {
            case .critical: return 5
            case .high: return 4
            case .medium: return 3
            case .low: return 2
            case .info: return 1
            }
        }

        static func < (lhs: Severity, rhs: Severity) -> Bool {
            lhs.score < rhs.score
        }
    }
}

/// Security score for a device
struct SecurityScore {
    let host: String
    let score: Int // 0-100
    let vulnerabilities: [Vulnerability]
    let checksPassed: Int
    let checksTotal: Int

    var grade: String {
        switch score {
        case 90...100: return "A"
        case 80..<90: return "B"
        case 70..<80: return "C"
        case 60..<70: return "D"
        default: return "F"
        }
    }

    var rating: String {
        switch score {
        case 90...100: return "Excellent"
        case 80..<90: return "Good"
        case 70..<80: return "Fair"
        case 60..<70: return "Poor"
        default: return "Critical"
        }
    }
}

/// Manages vulnerability scanning and detection
@MainActor
class VulnerabilityScanner: ObservableObject {
    @Published var vulnerabilities: [Vulnerability] = []
    @Published var isScanning = false
    @Published var progress: Double = 0
    @Published var currentHost: String = ""
    @Published var securityScores: [String: SecurityScore] = [:]

    // Vulnerable port definitions
    private let vulnerablePorts: [Int: (type: Vulnerability.VulnerabilityType, severity: Vulnerability.Severity, description: String)] = [
        21: (.openFTP, .high, "FTP service detected. FTP transmits credentials in plain text."),
        23: (.openTelnet, .critical, "Telnet service detected. Telnet is unencrypted and highly insecure."),
        25: (.openSMTP, .medium, "SMTP service detected. May be configured as an open relay."),
        69: (.insecureService, .medium, "TFTP service detected. TFTP has no authentication."),
        135: (.suspiciousPort, .high, "Windows RPC service detected. Often targeted by malware."),
        139: (.suspiciousPort, .medium, "NetBIOS service detected. Legacy protocol with security issues."),
        445: (.suspiciousPort, .high, "SMB service detected. Ensure latest security patches are applied."),
        1433: (.exposedDatabase, .critical, "Microsoft SQL Server detected. Should not be exposed to network."),
        1521: (.exposedDatabase, .critical, "Oracle Database detected. Should not be exposed to network."),
        3306: (.exposedDatabase, .critical, "MySQL database detected. Should not be exposed to network."),
        3389: (.unauthorizedAccess, .high, "RDP service detected. Ensure strong authentication is enabled."),
        5432: (.exposedDatabase, .critical, "PostgreSQL database detected. Should not be exposed to network."),
        5900: (.unauthorizedAccess, .high, "VNC service detected. Often has weak or no authentication."),
        6379: (.exposedDatabase, .high, "Redis detected. Should not be exposed without authentication."),
        8080: (.insecureService, .low, "HTTP proxy detected. Verify authentication is required."),
        27017: (.exposedDatabase, .critical, "MongoDB detected. Should not be exposed without authentication."),
    ]

    /// Scan a host for vulnerabilities
    func scanHost(host: String, openPorts: [Int]) async -> SecurityScore {
        currentHost = host
        var hostVulnerabilities: [Vulnerability] = []
        var checksTotal = 0
        var checksPassed = 0

        // Check each open port for known vulnerabilities
        for port in openPorts {
            checksTotal += 1

            if let vulnInfo = vulnerablePorts[port] {
                let vuln = Vulnerability(
                    type: vulnInfo.type,
                    severity: vulnInfo.severity,
                    host: host,
                    port: port,
                    description: vulnInfo.description,
                    recommendation: getRecommendation(for: vulnInfo.type),
                    detectedAt: Date()
                )

                hostVulnerabilities.append(vuln)
                vulnerabilities.append(vuln)
            } else {
                checksPassed += 1
            }
        }

        // Additional vulnerability checks
        checksTotal += 5

        // Check for anonymous FTP
        if openPorts.contains(21) {
            if await checkAnonymousFTP(host: host) {
                let vuln = Vulnerability(
                    type: .anonymousFTP,
                    severity: .critical,
                    host: host,
                    port: 21,
                    description: "FTP server allows anonymous login without credentials.",
                    recommendation: "Disable anonymous FTP access and require authentication.",
                    detectedAt: Date()
                )
                hostVulnerabilities.append(vuln)
                vulnerabilities.append(vuln)
            } else {
                checksPassed += 1
            }
        } else {
            checksPassed += 1
        }

        // Check for open SMTP relay
        if openPorts.contains(25) {
            if await checkOpenSMTPRelay(host: host) {
                let vuln = Vulnerability(
                    type: .openSMTP,
                    severity: .high,
                    host: host,
                    port: 25,
                    description: "SMTP server may be configured as an open relay.",
                    recommendation: "Configure SMTP server to reject unauthorized relay attempts.",
                    detectedAt: Date()
                )
                hostVulnerabilities.append(vuln)
                vulnerabilities.append(vuln)
            } else {
                checksPassed += 1
            }
        } else {
            checksPassed += 1
        }

        // Check SSL/TLS configuration
        if openPorts.contains(443) {
            let sslIssues = await checkSSLConfiguration(host: host, port: 443)
            hostVulnerabilities.append(contentsOf: sslIssues)
            vulnerabilities.append(contentsOf: sslIssues)

            if sslIssues.isEmpty {
                checksPassed += 1
            }
        } else {
            checksPassed += 1
        }

        // Check for unencrypted HTTP when HTTPS is available
        if openPorts.contains(80) && !openPorts.contains(443) {
            let vuln = Vulnerability(
                type: .missingEncryption,
                severity: .medium,
                host: host,
                port: 80,
                description: "HTTP service without HTTPS alternative.",
                recommendation: "Enable HTTPS and redirect HTTP traffic to HTTPS.",
                detectedAt: Date()
            )
            hostVulnerabilities.append(vuln)
            vulnerabilities.append(vuln)
        } else {
            checksPassed += 1
        }

        // Check for default credentials on common services
        let defaultCredChecks = await checkDefaultCredentials(host: host, ports: openPorts)
        hostVulnerabilities.append(contentsOf: defaultCredChecks)
        vulnerabilities.append(contentsOf: defaultCredChecks)

        if defaultCredChecks.isEmpty {
            checksPassed += 1
        }

        // Calculate security score
        let score = calculateSecurityScore(vulnerabilities: hostVulnerabilities, checksPassed: checksPassed, checksTotal: checksTotal)

        let securityScore = SecurityScore(
            host: host,
            score: score,
            vulnerabilities: hostVulnerabilities,
            checksPassed: checksPassed,
            checksTotal: checksTotal
        )

        securityScores[host] = securityScore
        return securityScore
    }

    /// Check for anonymous FTP access
    private func checkAnonymousFTP(host: String) async -> Bool {
        // Attempt connection with anonymous credentials
        // In a real implementation, this would try to login with "anonymous" user
        // For now, return false (would require actual FTP protocol implementation)
        return false
    }

    /// Check for open SMTP relay
    private func checkOpenSMTPRelay(host: String) async -> Bool {
        // Test if SMTP server accepts mail relay without authentication
        // Real implementation would connect and test MAIL FROM/RCPT TO commands
        return false
    }

    /// Check SSL/TLS configuration
    private func checkSSLConfiguration(host: String, port: Int) async -> [Vulnerability] {
        var issues: [Vulnerability] = []

        // Note: Full SSL/TLS inspection requires certificate validation
        // which is complex on tvOS. This is a simplified check.

        let connection = NWConnection(
            host: NWEndpoint.Host(host),
            port: NWEndpoint.Port(integerLiteral: UInt16(port)),
            using: .tls
        )

        let result = await testConnection(connection)

        if !result {
            issues.append(Vulnerability(
                type: .weakSSL,
                severity: .high,
                host: host,
                port: port,
                description: "SSL/TLS connection could not be established with secure parameters.",
                recommendation: "Ensure server supports TLS 1.2 or higher with strong cipher suites.",
                detectedAt: Date()
            ))
        }

        return issues
    }

    /// Test connection helper
    private func testConnection(_ connection: NWConnection) async -> Bool {
        await withCheckedContinuation { continuation in
            let queue = DispatchQueue(label: "ssl-test")
            var hasResumed = false
            let lock = NSLock()

            connection.stateUpdateHandler = { state in
                lock.lock()
                defer { lock.unlock() }

                guard !hasResumed else { return }

                switch state {
                case .ready:
                    hasResumed = true
                    connection.cancel()
                    continuation.resume(returning: true)

                case .failed, .cancelled:
                    hasResumed = true
                    connection.cancel()
                    continuation.resume(returning: false)

                default:
                    break
                }
            }

            connection.start(queue: queue)

            queue.asyncAfter(deadline: .now() + 3) {
                lock.lock()
                defer { lock.unlock() }

                if !hasResumed {
                    hasResumed = true
                    connection.cancel()
                    continuation.resume(returning: false)
                }
            }
        }
    }

    /// Check for default credentials
    private func checkDefaultCredentials(host: String, ports: [Int]) async -> [Vulnerability] {
        var issues: [Vulnerability] = []

        // Common services with default credentials
        let defaultCredServices: [Int: String] = [
            22: "SSH",
            23: "Telnet",
            3389: "RDP",
            5900: "VNC",
            8080: "Web Admin"
        ]

        for port in ports {
            if let service = defaultCredServices[port] {
                // In a real implementation, this would attempt common default credentials
                // For now, we just warn about the possibility
                issues.append(Vulnerability(
                    type: .defaultCredentials,
                    severity: .high,
                    host: host,
                    port: port,
                    description: "\(service) service may be using default credentials.",
                    recommendation: "Verify that default credentials have been changed.",
                    detectedAt: Date()
                ))
            }
        }

        return issues
    }

    /// Calculate security score
    private func calculateSecurityScore(vulnerabilities: [Vulnerability], checksPassed: Int, checksTotal: Int) -> Int {
        guard checksTotal > 0 else { return 100 }

        // Start with base score from checks passed
        var score = (checksPassed * 100) / checksTotal

        // Deduct points for each vulnerability based on severity
        for vuln in vulnerabilities {
            switch vuln.severity {
            case .critical: score -= 20
            case .high: score -= 15
            case .medium: score -= 10
            case .low: score -= 5
            case .info: score -= 2
            }
        }

        return max(0, min(100, score))
    }

    /// Get recommendation for vulnerability type
    private func getRecommendation(for type: Vulnerability.VulnerabilityType) -> String {
        switch type {
        case .openTelnet:
            return "Disable Telnet and use SSH instead for secure remote access."
        case .openFTP:
            return "Use SFTP or FTPS instead of plain FTP for secure file transfer."
        case .anonymousFTP:
            return "Disable anonymous FTP access and require authentication."
        case .openSMTP:
            return "Configure SMTP server to require authentication and reject unauthorized relays."
        case .weakSSL:
            return "Disable SSLv3, TLS 1.0, and TLS 1.1. Use TLS 1.2+ with strong cipher suites."
        case .exposedDatabase:
            return "Database ports should not be exposed to the network. Use firewall rules and VPN access."
        case .defaultCredentials:
            return "Change all default passwords and usernames immediately."
        case .openDNS:
            return "Configure DNS server to only respond to authorized clients."
        case .unauthorizedAccess:
            return "Enable strong authentication, use VPN, and restrict access by IP address."
        case .insecureService:
            return "Review service configuration and enable security features."
        case .missingEncryption:
            return "Enable encryption for all services handling sensitive data."
        case .suspiciousPort:
            return "Verify this service is necessary and ensure it's properly secured."
        }
    }

    /// Clear all vulnerabilities
    func clearVulnerabilities() {
        vulnerabilities.removeAll()
        securityScores.removeAll()
    }

    /// Export vulnerability report
    func exportReport() -> String {
        var report = "# Security Vulnerability Report\n"
        report += "# Generated: \(Date())\n"
        report += "# Total Vulnerabilities: \(vulnerabilities.count)\n\n"

        let groupedByHost = Dictionary(grouping: vulnerabilities, by: { $0.host })

        for (host, vulns) in groupedByHost.sorted(by: { $0.key < $1.key }) {
            report += "## Host: \(host)\n"

            if let score = securityScores[host] {
                report += "Security Score: \(score.score)/100 (Grade: \(score.grade))\n"
                report += "Checks Passed: \(score.checksPassed)/\(score.checksTotal)\n\n"
            }

            for vuln in vulns.sorted(by: { $0.severity > $1.severity }) {
                report += "### [\(vuln.severity.rawValue)] \(vuln.type.rawValue)\n"
                if let port = vuln.port {
                    report += "Port: \(port)\n"
                }
                report += "Description: \(vuln.description)\n"
                report += "Recommendation: \(vuln.recommendation)\n\n"
            }

            report += "\n"
        }

        return report
    }
}
